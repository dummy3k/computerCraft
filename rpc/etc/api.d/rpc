PROTOCOLL = "rpc"
VERSION = "0.18"

local function get_info(obj)
	for k, v in pairs(obj) do
		print(k..": "..type(v))
	end
end

local function lookup_str(s, _GG)
	if s == "shell" then
		return _GG[s]
	end
	
	local obj = _G
	for item in string.gmatch(s, "[^\\.]+") do
		obj = obj[item]
	end
	return obj
end

function getVersion()
	return VERSION
end

--------------------------------------------------------------------------------
--	Server
--------------------------------------------------------------------------------

--msg = {cmd="rpc", obj="math", method="min", args={1, 2}}
local function cmd_call(host, msg, _GG)
	-- retVal = {_G[msg.obj][msg.method](unpack(msg.args))}
	local retVal = {lookup_str(msg.obj, _GG)[msg.method](unpack(msg.args))}
	retVal = textutils.serialize(retVal)
	-- print("retVal: ",retVal)
	rednet.send(host, retVal, PROTOCOLL)
end

local function cmd_list(host, msg, _GG)
	local retVal = {}
	-- print(lookup_str(msg.obj))
	for k, v in pairs(lookup_str(msg.obj, _GG)) do
		-- print(k..": "..type(v))
		retVal[k] = type(v)
	end
	
	retVal = textutils.serialize(retVal)
	-- print("retVal: ",retVal)
	rednet.send(host, retVal, PROTOCOLL)
end

local function cmd_ping(host, msg, _GG)
	-- retVal = textutils.serialize(retVal)
	retVal = "pong"
	-- print("foo?")
	-- print("retVal: ",retVal)
	rednet.send(host, retVal, PROTOCOLL)
end

function daemon(_GG)
	print("rpc v"..VERSION.." daemon started...")
	local msg = {cmd="startup", version=VERSION}
	rednet.broadcast(textutils.serialize(msg), PROTOCOLL)
	
	-- print("shell", shell)
	-- print("shell", _GG["shell"])
	local commands = {}
	commands["rpc"] = cmd_call
	commands["list"] = cmd_list
	commands["ping"] = cmd_ping
	commands["startup"] = function (...) end
	
	while true do
		host, msg, prot = rednet.receive(PROTOCOLL)
		-- print(host..", "..msg..", "..tostring(prot))
		-- print("<",msg)
		msg = textutils.unserialize(msg)
		local fn_cmd = commands[msg.cmd]
		if not commands[msg.cmd] then
			print("unkown cmd: ", msg.cmd)
		else
			commands[msg.cmd](host, msg, _GG)
		end
	end	
end

--------------------------------------------------------------------------------
--	Client
--------------------------------------------------------------------------------
function query(host, msg, verbose, timeout)
	local msg = textutils.serialize(msg)
	if verbose then
		print(">", msg)
	end
	rednet.send(host, msg, PROTOCOLL)
	local p1, p2
	while true do
		p1, p2 = rednet.receive(PROTOCOLL, 2)
		-- print(p1..": "..tostring(p2))
		-- print(host, p1, "<", p2)
		if verbose then
			print("<", p2)
		end
		-- if not p2 then
			-- error("timeout")
			-- return
		-- end
		
		if p1 == host then
			break
		-- else
			-- print("wrong host")
		end
	end
	-- print("here?")
	-- print("<", p2)
	textutils.unserialize(p2)
	-- print("here?")
	
	-- p2 = textutils.unserialize(p2)
	return textutils.unserialize(p2)
end

function createProxy(host, obj, verbose, timeout)
	local retVal = {}
	for k, v in pairs(query(host, {cmd="list", obj=obj})) do
		-- print(k..": "..tostring(v))
		retVal[k] = function (...)
			local tArgs = {...}
			msg = {cmd="rpc", obj=obj, method=k, args=tArgs}
			return unpack(query(host, msg))
		end
	end
	return retVal
end

function createSwarm(hosts, obj, verbose, timeout)
	local retVal = {}
	for k, v in pairs(rpc.query(hosts[1], {cmd="list", obj=obj})) do
		-- print(k..": "..tostring(v))
		retVal[k] = function (...)
			local tArgs = {...}
			local retVal2 = {}
			local msg = {cmd="rpc", obj=obj, method=k, args=tArgs}
			local fns = {}
			for k2, host in pairs(hosts) do
				-- print(k2..": "..tostring(host))
				fns[#fns + 1] = function ()
						-- print(host, msg) 
						retVal2[host] = rpc.query(host, msg) 
					end
			end
			parallel.waitForAll(unpack(fns))
			return retVal2
			--return unpack(query(host, msg))
		end
	end
	return retVal
end

function scan()
	local msg = {cmd="ping"}
	msg = textutils.serialize(msg)
	rednet.broadcast(msg, rpc.PROTOCOLL)
	
	local retVal = {}
	while true do
		-- print("hi")
		p1, p2 = rednet.receive(PROTOCOLL, 2)
		if not p1 then
			break
		end
		retVal[#retVal + 1] = p1
	end
	return retVal
end

--------------------------------------------------------------------------------
--	CLI
--------------------------------------------------------------------------------
local function trimWordList(choices, curText)
	local retVal = {}
	for idx = 1, #choices do
		local word = choices[idx]
		if word:sub(1, #curText) == curText then
			retVal[#retVal + 1] = word:sub(#curText + 1)
		end
	end
	return retVal
end

--	http://computercraft.info/wiki/Shell.setCompletionFunction
local function tabCompletionFunction(shell, parNumber, curText, lastText)
	-- print("curText:",curText,"#")
	-- print("parNumber:",parNumber,"#")
	-- for k, v in pairs(lastText) do
		-- print(k..": "..tostring(v))
	-- end	

	
	local retVal = {}
	if parNumber == 1 then
		return trimWordList({"scan", "help", "version", "install"}, curText)
		
	elseif parNumber == 2 then
		if lastText[#lastText] == "install" then
			return trimWordList({"aaa", "bbb"}, curText)
		end
	end
	
	
	return {}
end

function registerCompletionFunction(shell)
	shell.setCompletionFunction("bin/rpc", tabCompletionFunction)
end

